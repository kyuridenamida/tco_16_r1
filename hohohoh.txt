#include <algorithm>
#include <cstdlib>
#include <iostream>
#include <map>
#include <stack>
#include <cassert>
#include <sstream>
#include <vector>
using namespace std;
/* 超注意：　ほとんどのアルゴリズムは多角形が反時計回りであることを仮定する． */
#include <vector>
#include <complex>
#include <algorithm>
#include <cassert>
#include <list>
#include <array>
#include <cmath>
using namespace std;
static const double EPS = 1e-9;
const double INF = 1e12;
const double PI = acos(-1);
#define REP(i, n) for ( int i = 0; i < (n); i++ )

struct P{
	double x,y;
	P(){x=y=0;}
	P(double x,double y) : x(x), y(y) {}
	P operator+(const P &t) const {
		return P(x + t.x, y + t.y);
	}
	P operator-(const P &t) const {
		return P(x - t.x, y - t.y);
	}
	P operator*(double t) const {
		return P(x * t, y * t);
	}
	P operator*(const P &t) const {
		return P(x*t.x-y*t.y,y*t.x+x*t.y);
	}
	P operator/(double t) const {
		return P(x / t, y / t);
	}
	bool operator == (const P &t) const{
		return t.x == x and t.y == y;
	}
	bool operator != (const P &t) const{
		return t.x != x or t.y != y;
	}
};
P operator * (double t,const P &a){
	return P(a.x * t, a.y * t);
}
typedef vector<P> G;

bool operator < (const P& a, const P& b) {
	return a.x != b.x ? a.x < b.x : a.y < b.y;
}

inline double cross(const P &a,const P &b) { return a.x * b.y - a.y * b.x; }
inline double dot(const P &a,P const &b) { return a.x * b.x + a.y * b.y; }
inline double norm(const P &a){ return a.x * a.x + a.y * a.y; }
inline double abs(const P &a){ return sqrt(a.x * a.x + a.y * a.y); }


//直線
struct L{
	P a,b;
	double A,B,C;
	L(const P &a,const P &b) : a(a), b(b) {
		double X0 = a.x;
		double Y0 = a.y;
		double X1 = b.x;
		double Y1 = b.y;
		A = (Y1-Y0);
		B = (X0-X1);
		C = Y0 * (X1-X0) + X0 * (Y0-Y1);
	}
	bool operator == (const L &t) const{
		return t.a == a and t.b == b;
	}
	bool operator != (const L &t) const{
		return t.a != a or t.b != b;
	}

	bool operator < (const L& t) const {
		return a != t.a ? a < t.a : b < t.b;
	}
};


int ccw(P a, P b, P c) {
	b = b - a; c = c - a;
	if (cross(b, c) > 0)   return +1;	// a → b で反時計方向に折れて b → c(？)
	if (cross(b, c) < 0)   return -1;	// a → b で時計方向に折れて b → c(？)
	if (dot(b, c) < 0) return +2;    	// a→bで逆向いてaを通り越してb→c(c--a--b)
	if (norm(b) < norm(c)) return -2;	// a→bでそのままb→c(a--b--c)
	return 0;							// a→bで逆向いてb→c(または b == c)
}

bool intersectLS(const L &l, const L &s) {
	return (l.A*s.a.x+l.B*s.a.y+l.C) * (l.A*s.b.x+l.B*s.b.y+l.C) < EPS;
	return cross(l.b-l.a, s.a-l.a)*cross(l.b-l.a, s.b-l.a) < EPS;
}



inline double distanceLP_check(const L &l, const P &p,const double &r) {
	return (l.A*p.x+l.B*p.y+l.C)*(l.A*p.x+l.B*p.y+l.C) > r * r * (l.A*l.A+l.B*l.B) + EPS;
}

 
P crosspoint(const L &l, const L &m) {
	double y = - (l.C * m.A - l.A * m.C) / (l.B * m.A - l.A * m.B);
	double x = (-l.B * y - l.C) / l.A;
	return P(x,y);
	
	// double A = cross(l.b - l.a, m.b - m.a);
	// double B = cross(l.b - l.a, l.b - m.a);
	// if (abs(A) < EPS && abs(B) < EPS) return m.a;
	// return m.a + B / A * (m.b - m.a);
}
 
#define curr(P, i) P[(i) % P.size()]
#define next(P, i) P[(i+1)%P.size()]
#define prev(P, i) P[(i+P.size()-1) % P.size()]

// 単純多角形の面積の"2倍"を求める O(n)
double area2(const G& poly) {
	double A = 0;
	REP(i,poly.size()) A += cross(curr(poly, i), next(poly, i));
	return A;
}
// 凸包を求める O(n log n)
vector<P> convex_hull2(vector<P> ps) {
  if( ps.size() < 3 ) return ps;
  int n = ps.size(), k = 0;
  sort(ps.begin(), ps.end());

  vector<P> ch(2*n);
  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull
    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;
  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull
    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;
  ch.resize(k-1);
  return ch;
}
vector<P> convex_hull(vector<P> ps) {
  int n = ps.size(), k = 0;
  while( ps.size() < 3 )
	ps.push_back(ps[0] + P(0.00001 * (rand() % 100),0.00001 * (rand() % 100)));
  sort(ps.begin(), ps.end());

  vector<P> ch(2*n);
  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull
    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;
  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull
    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;
  ch.resize(k-1);
  return ch;
}



//http://d.hatena.ne.jp/TobiasGSmollett/20150220/1424445987
//お借りした
struct Circle{
  P p;
  double r;
  vector<P> ps;
  Circle(){}
  Circle(P p, double r) : p(p) , r(r){}
  Circle(P p, double r,vector<P> ps) : p(p) , r(r), ps(ps) {}
  
  
  bool contain(P a){
    return norm(a-p) <= r * r;
  }
  
  static Circle circumCircle(P a,P b){
    P q=(a+b)/2.0;
	return Circle(q,abs(a-q));
  }
  
  static Circle circumscribedCircle(P p, P q, P r){
    P a=(q-p)*2.0,b=(r-p)*2.0;
    P c(dot(p,p)-dot(q,q),dot(p,p)-dot(r,r));
    Circle res;
	double x = a.y*c.y-b.y*c.x;
    double y = b.x*c.x-a.x*c.y;
    res.p = P(x,y)/cross(a,b);
    return Circle(res.p, abs(p-res.p));
  }

  static Circle minEnclosingCircle(vector<P>ps){
    if(ps.size()==0) return Circle(P(0,0),0,{});
    if(ps.size()==1) return Circle(ps[0],0,{ps[0]});
	if(ps.size()==2){
		Circle c = circumCircle(ps[0],ps[1]);
		c.ps = {ps[0],ps[1]};
		return c;
	}
    Circle circle=circumscribedCircle(ps[0],ps[1],ps[2]);
	circle.ps = {ps[0],ps[1],ps[2]};
	
    for(int i=2;i<ps.size();i++){
      if(!circle.contain(ps[i])){
			circle=circumscribedCircle(ps[0],ps[1],ps[i]);
			circle.ps = {ps[0],ps[1],ps[i]};
			for(int j=1;j<i;j++){
			  if(!circle.contain(ps[j])){
				circle=circumscribedCircle(ps[0],ps[j],ps[i]);
				circle.ps = {ps[0],ps[j],ps[i]};
				for(int k=0;k<j;k++){
				  if(!circle.contain(ps[k])){
					circle=circumscribedCircle(ps[i],ps[j],ps[k]);
					circle.ps = {ps[i],ps[j],ps[k]};
				  }
				}
			  }
			}
      }
    }
    return circle;
  }

};

namespace Utils{
	void reflesh_max(vector<double> &a,const vector<double> &b){
		for(int i = 0 ; i < a.size() ; i++)
			a[i] = max(a[i],b[i]);
	}
	int to_int(double x){
		return x + 0.5;
	}
};


class GeomUtils{
public:
	static bool is_separating(L l,P p1,P p2){
		int r1 = ccw(l.a,l.b,p1);
		int r2 = ccw(l.a,l.b,p2);
		return abs(r1) == 1 && abs(r2) == 1 && r1 != r2;
	}
	static L convert_to_integer_line(L l,P p1,P p2){
		// cout << l.b << " " << l.a << endl;
		P vec = (l.b - l.a) / abs(l.b-l.a);
		// cout << vec << endl;
		if( abs(vec.x) < EPS ) {
			int x = (l.a.x+0.5);
			return L(P(x,0),P(x,1));
		}
		if( abs(vec.y) < EPS ){
			int y = (l.a.y+0.5);
			return L(P(0,y),P(1,y));
		}
		P vx = vec / vec.x;
		//cout << vx << endl;
		vector< pair<double,P> > ps;
		for(int i = 0 ; i <= 1024 ; i++){
			P t = l.a + (i-l.a.x) * vx;
			if( -EPS <= t.x && t.x <= 1024 + EPS && 
				-EPS <= t.y && t.y <= 1024 + EPS ){
				int X = t.x + 0.5;
				int Y = t.y + 0.5;
				ps.push_back({abs(t.x-X)+abs(t.y-Y),P(X,Y)});
			}
		}
		P vy = vec / vec.y;
		// cout << l.a << " " << vy << endl;
		for(int i = 0 ; i <= 1024 ; i++){
			P t = l.a + (i-l.a.y) * vy;
			if( -EPS <= t.x && t.x <= 1024 + EPS && 
				-EPS <= t.y && t.y <= 1024 + EPS ){
				int X = t.x + 0.5;
				int Y = t.y + 0.5;
				ps.push_back({abs(t.x-X)+abs(t.y-Y),P(X,Y)});
			}
		}
		sort(ps.begin(),ps.end());
		
		for(int i = 0 ; i < ps.size() ; i++){
			for(int j = i+1 ; j < ps.size() ; j++){
				if( abs(ps[i].second-ps[j].second) < EPS ) continue;
				if( GeomUtils::is_separating(L(ps[i].second,ps[j].second),p1,p2) ){
					return L(ps[i].second,ps[j].second);
				}
			}
		}
		return L(P(-1,-1),P(-1,-1));
	}
};


using namespace Utils;
const P null_point = P(-1,-1);
const L null_line = L(null_point,null_point);

uint32_t xor64(void) {
  static uint64_t x = 88172645463325252ULL;
  x = x ^ (x << 13); x = x ^ (x >> 7);
  return x = x ^ (x << 17);
}

struct Edge{
	int src,dst;
	Edge(int src,int dst) : src(src), dst(dst) {}
};


class Tree{
public:
	int id;
	int n;
	vector<Edge> es;
	vector<P> position;
	int root;
	vector<Circle> mec;
	vector<P> convex_polygon;
	vector<vector<int>> child;
	vector<vector<L>> child_line;
	vector<int> parent;
	vector<int> depth;
	vector<double> length_between_parent;
	vector<double> tot_sum_of_tree;
	Tree(int id,int n,const vector<Edge> es,vector<P> position,int root) : id(id), n(n), es(es), position(position), root(root){
		//convex_polygon = convex_hull(position);
		
		
		
		parent = vector<int>(n,-1);
		depth = vector<int>(n);
		child = vector<vector<int>>(n);
		child_line = vector<vector<L>>(n);
		tot_sum_of_tree = length_between_parent = vector<double>(n,0);
		mec =  vector<Circle>(n,Circle(P(0,0),-1));
		
		vector<vector<int>> g(n);
		for( auto e : es ){
			g[e.src].push_back(e.dst);
			g[e.dst].push_back(e.src);
		}
		
		stack< array<int,3> > S;
		S.push(array<int,3>{root,-1,0});
		while( S.size() ){
			int x = S.top()[0];
			int p = S.top()[1];
			int d = S.top()[2];
			S.pop();
			parent[x] = p;
			depth[x] = d;
			for( auto e : g[x] ){
				if( e != p ){
					
					length_between_parent[e] = abs(position[e]-position[x]);
					S.push(array<int,3>{e,x,d+1});
					child[x].push_back(e);
					child_line[x].push_back(L(position[x],position[e]));
				}
			}
		}
		init_dfs(root);
	}
	vector<P> init_dfs(int x){
		tot_sum_of_tree[x] = 0.0;
		vector<P> ps;
		ps.push_back(position[x]);
		
		for( auto c : child[x] ){
			vector<P> X = init_dfs(c);
			tot_sum_of_tree[x] += tot_sum_of_tree[c];// + length_between_parent[c];
			ps.insert(ps.end(),X.begin(),X.end());
		}
	
		
		ps = convex_hull2(ps);
		mec[x] = Circle::minEnclosingCircle(ps);
		tot_sum_of_tree[x] += length_between_parent[x];
		// cerr << tot_sum_of_tree[x] << endl;
		//cerr << ps.size() << endl;
		return ps;
	}
};


class Problem{
public:
	vector<Tree> trees;
	Problem(int NP,vector<int> points,vector<int> roots){
		int n = points.size() / 2;
		
		map<P,vector<P>> graph;
		map<int,P> id_to_pos;	
		for(int i = 0 ; i < n ; i++)
			id_to_pos[i] = P(points[2*i],points[2*i+1]);
		
		vector<vector<int>> g(id_to_pos.size());
		for(int i = 0 ; i < roots.size() ; i += 2 ){
			g[roots[i]].push_back(roots[i+1]);
			g[roots[i+1]].push_back(roots[i]);
		}
		vector<bool> done(n,false);
		for(int root = 0 ; root < n ; root++){
			if( !done[root] ){
				map<int,int> relabel;
				vector<Edge> es;
				inner_listup_component(root,g,done,relabel,es);
				vector<P> position(relabel.size());
				for( auto r : relabel )
					position[r.second] = id_to_pos[r.first];
				trees.push_back(Tree(trees.size(),position.size(),es,position,0));
			}
		}
		assert( trees.size() == NP );
	}
private:
	void inner_listup_component(int x,const vector<vector<int>> &g,vector<bool> &done, map<int,int> &relabel,vector<Edge> &es){
		assert( !done[x] );
		done[x] = true;
		int k = relabel.size();
		relabel[x] = k;
		for( auto to : g[x] ){
			if( !done[to] ){
				inner_listup_component(to,g,done,relabel,es);
				es.push_back(Edge(relabel[x],relabel[to]));
			}
		}
		
		
	
	}
};


class Answer{
public:
	vector<L> lines; 
	Answer(){}
	Answer(vector<int> ps){
		assert(ps.size() % 2 == 0);
		for(int i = 0 ; i < ps.size() ; i += 4){
			lines.push_back(L(P(ps[i],ps[i+1]),P(ps[i+2],ps[i+3])));
		}
	}
	void add_line(const L &line){
		lines.push_back(line);
	}
	vector<int> to_vector(){
		vector<int> vs;
		for( auto line : lines ){
			vs.push_back(line.a.x+0.5);
			vs.push_back(line.a.y+0.5);
			vs.push_back(line.b.x+0.5);
			vs.push_back(line.b.y+0.5);
		}
		return vs;
	}
};

class RGB{
public:
	int r,g,b;
	RGB(int r=0,int g=0,int b=0) : r(r), g(g), b(b) {}
	static RGB random(){
		RGB res;
		res.r = rand() % 256;
		res.g = rand() % 256;
		res.b = rand() % 256;
		return res;
	}
};



class ExtendedAnswer : public Answer{
public:
	Problem* problem;
	ExtendedAnswer(){}
	ExtendedAnswer(Problem *problem) : problem(problem){
		double all_total = 0;
		for(const auto &tree : problem->trees ){
			all_total += tree.tot_sum_of_tree[0];
			MEMO_score_of_tree.push_back(tree.tot_sum_of_tree[0]);
			current_weight.push_back(vector<double>(tree.n,-1.0));
			already_cut.push_back(vector<bool>(tree.n,false));
			inner_init_dfs_score_of_tree(tree.root,tree);
		}
		// cerr << all_total << "<" << endl;
		MEMO_overall_score = all_total;
		
	}
	void add_line(const L &line){
		lines.push_back(line);
		// overall_score_rough(line,true);
		overall_score(line,true);
	}
	
	vector<double> MEMO_score_of_tree;

	double score_of_tree(const Tree &tree,const L &l = null_line,bool reflesh=true){
		if( l == null_line )
			return MEMO_score_of_tree[tree.id];
		double res = inner_dfs_score_of_tree(tree.root,tree,l,reflesh);
		if( reflesh ){
			MEMO_score_of_tree[tree.id] = res;
		}
		return res;
	}


	double MEMO_overall_score;
	double overall_score(const L &l = null_line,bool reflesh=false){
		if( l == null_line )
			return MEMO_overall_score;

		double sum = 0;
		for( const auto &tree : problem->trees ){
			sum += score_of_tree(tree,l,reflesh);
		}
		if( reflesh ){
			MEMO_overall_score = sum;
		}
		return sum;
	}

	vector< vector<double> > current_weight;
	vector< vector<bool> > already_cut;
	
	double inner_init_dfs_score_of_tree(int x,const Tree &tree){
		double sum = 0;
		for( auto c : tree.child[x] ){
			sum += inner_init_dfs_score_of_tree(c,tree);
		}
		return current_weight[tree.id][x] = sum + tree.length_between_parent[x];
	}
	
	double inner_dfs_score_of_tree(int x,const Tree &tree,const L &line,bool reflesh){
		
		if( distanceLP_check(line,tree.mec[x].p,tree.mec[x].r) ){
			return current_weight[tree.id][x];
		}
		if( already_cut[tree.id][x] ) return current_weight[tree.id][x];


		double sum = 0;
		for(int i = 0 ; i < tree.child[x].size() ; i++){
			const int &c = tree.child[x][i];
			const L &cline = tree.child_line[x][i];
			
			if( intersectLS(line,cline) ){
				P cp = crosspoint(line,cline);
				double cut_dist = min( current_weight[tree.id][c], abs(cp-tree.position[x]) );
				if( reflesh ){
					already_cut[tree.id][c] = true;
					current_weight[tree.id][c] = cut_dist ; // 枝がさらにカットされたとき対策
				}
				sum += cut_dist;
			}else{
				sum += inner_dfs_score_of_tree(c,tree,line,reflesh);			
			}
		}
		
		double res = sum + tree.length_between_parent[x];
		if( reflesh ){
			current_weight[tree.id][x] = res;
		}
		return res;
	}
	vector<double> get_ratio(){
		vector<double> res;
		for( const auto &tree : problem->trees ){
			res.push_back(score_of_tree(tree) / tree.tot_sum_of_tree[0]);
			//cerr << tree.id << "|" << score_of_tree(tree) / tree.tot_sum_of_tree[0] << "|" << score_of_tree(tree)  << "/" <<  tree.tot_sum_of_tree[0] << endl;
		}
		//cerr << "--------" << endl;
		return res;
	}

	void inner_draw_tree(int x,bool dead,const Tree &tree,const RGB &alive){
		if( already_cut[tree.id][x] ){
			dead = true;	
			return;
		}
		
		
		
		
		
		for( auto c : tree.child[x] ){
			if( !already_cut[tree.id][c] ){ 
				cout << "S " << max(alive.r - 100 * dead,0) << " " << max(alive.g - 100 * dead,0) << " " << max(alive.b - 100 * dead,0) << " " << to_int(tree.position[x].x) << " " << to_int(tree.position[x].y) << " " << to_int(tree.position[c].x) << " " << to_int(tree.position[c].y) << endl;
				inner_draw_tree(c,dead,tree,alive);
			}
		}
		
		return;
	}
	void draw_sol(){
		cout << "C " << 128 << " " << 128 << " " << 128 << " " << 512 << " " << 512 << " " << 512 << endl;	
		static vector<RGB> cs;
		while( cs.size() < 200 ) cs.push_back(RGB::random());
		
		for( auto& tree : problem->trees ){
			inner_draw_tree(0,false,tree,cs[tree.id]);
		}
		for( auto &l : lines ){
			cout << "L " << 255 << " " << 255 << " " << 255 << " " << to_int(l.a.x) << " " << to_int(l.a.y) << " " << to_int(l.b.x) << " " << to_int(l.b.y) << endl;
		}
		cout << "END" << endl;
	}
	ExtendedAnswer refined_answer(){
		for(int i = 0 ; i < lines.size() ; ){
				vector<L> ls;
				for(int j = 0 ; j < lines.size() ; j++)
					if( i != j ) ls.push_back(lines[j]);
				bool f = true;
				for(int j = 0 ; j < problem->trees.size() ; j++){
					for(int k = j+1 ; k < problem->trees.size() ; k++){
						P p1 = problem->trees[j].position[problem->trees[j].root];
						P p2 = problem->trees[k].position[problem->trees[k].root];
						bool separated = false;
						for( auto l : ls ){
							if( GeomUtils::is_separating(l,p1,p2) ){
								separated = true;
								break;
							}
						}
						if( !separated ) {
							f = false;
							break;
						}
					}
					if( !f ) break;
				}
				if( f ) {
					lines.erase(lines.begin()+i);
					
					//cerr << "OK" << endl;
				}else i++;
			}
			ExtendedAnswer hogehoge(problem);
			for(int i = 0 ; i < lines.size() ; i++){
				hogehoge.add_line(lines[i]);
			}
			return hogehoge;
	}

};



void inner_dfs_remaked_tree(int x,int bit,Tree &tree,const vector<ExtendedAnswer> &answers){
	for(int i = 0 ; i < answers.size() ; i++){
		if( answers[i].already_cut[tree.id][x] ) bit |= 1 << i;	
	}
	// cerr << bit << endl;
	if( bit == (1<<answers.size()) - 1 ){
		tree.child[x].clear();
		return;
	}
	
	for( auto c : tree.child[x] ){
		inner_dfs_remaked_tree(c,bit,tree,answers);
	}
	
	return;
}
void remake_tree(Tree &tree, const vector<ExtendedAnswer> &answers){
	assert( answers.size() <= 32 );
	inner_dfs_remaked_tree(0,0,tree,answers);
	tree.init_dfs(0);
	
}
Problem* remake_trees(Problem *problem,const vector<ExtendedAnswer> &answers){
	Problem* new_prob = new Problem(*problem);
	for(int i = 0 ; i < new_prob->trees.size() ; i++){
		remake_tree(new_prob->trees[i],answers);
	}
	return new_prob;
}

#include <cstdio>

const double TIME_LIMIT = 9.8;

namespace MyTimer{
	unsigned long long int cycle_per_sec = 2500000000;
	unsigned long long int beginCycle;
	unsigned long long int getCycle()
	{
	  unsigned int low, high;
	  __asm__ volatile ("rdtsc" : "=a" (low), "=d" (high));
	  return ((unsigned long long int)low) | ((unsigned long long int)high << 32);
	}
	double nowTime()
	{
	  return (double)(getCycle() - beginCycle) / cycle_per_sec;
	}
	void resetTimer(){
		beginCycle = getCycle();
	}
	bool isTLE(double limit){
		return nowTime() >= limit;
	}
};
using namespace MyTimer;

struct Configuration{
	bool visualize_mode;
	Configuration(){
		visualize_mode = false;
	}
} configuration;
class CutTheRoots {
public:
	
    vector<int> makeCuts(int NP, vector<int> points, vector<int> roots) {
		// srand(time(NULL));
		resetTimer();
		Problem problem(NP,points,roots);
		// if( configuration.visualize_mode ){
			// ExtendedAnswer answer_tmp(&problem);
			// answer_tmp.draw_sol();
		// }
		
		// if( configuration.visualize_mode ){
			// ExtendedAnswer answer_tmp(&problem);
			// answer_tmp.draw_sol();
			// return {};
		// }
		double current = -1e9;
		Answer res_ans;
		
		while( nowTime() < TIME_LIMIT ){
			//cerr << NaiveScoring::overall_score(problem,{}) << endl;
			ExtendedAnswer answer = greedy1(problem);
			return answer.to_vector();
			if( nowTime() < TIME_LIMIT ){
				if( answer.overall_score() > current ){
					res_ans = answer;
					current = answer.overall_score();
				}
			}
			break;
		}
		// cerr << NaiveScoring::overall_score(problem,answer) << endl;
        return res_ans.to_vector();
    }
	Problem *preprocess(Problem &problem){
		int N = problem.trees.size();

		vector<pair<double,pair<int,int>>> pairs;
		for(int i = 0 ; i < N ; i++){
			for(int j = i+1; j < N ; j++){
				P p1 = problem.trees[i].position[problem.trees[i].root];
				P p2 = problem.trees[j].position[problem.trees[j].root];
				pairs.push_back({norm(p1-p2),{i,j}});
			}
		}
		
		sort(pairs.begin(),pairs.end());
		
		
		vector<ExtendedAnswer> answers;
		
		for(int _ = 0 ; _ < 5 ; _++){
			ExtendedAnswer answer(&problem);
			for(int li = 0 ; li < pairs.size(); li++){
				int i = pairs[li].second.first;
				int j = pairs[li].second.second;
				P p1 = problem.trees[i].position[problem.trees[i].root];
				P p2 = problem.trees[j].position[problem.trees[j].root];
				bool separated = false;
				for( auto l : answer.lines ){
					if( GeomUtils::is_separating(l,p1,p2) ){
						separated = true;
						break;
					}
				}
				
				if( !separated ){
					vector<pair<double,L>> cand;
					double cur = answer.overall_score();
					for(int m = 0 ; m < 8000 / problem.trees.size() ; m++){
						double A = 1. * xor64() / (unsigned int)(-1);
						double B = 1. * xor64() / (unsigned int)(-1);
						P mp = p1 + (p2-p1) * A;
					// cerr << cur << " " << NaiveScoring::overall_score_fast(problem,answer) << "|" <<  NaiveScoring::overall_score(problem,answer) << endl;
						complex<double> rot = exp(complex<double>(0,PI*B));
						P vec = (p1-p2) * P(rot.real(),rot.imag());
						L l = L(mp,mp+vec);
						if( l.a != P(-1,-1) and GeomUtils::is_separating(l,p1,p2) ){
							double loss = cur - answer.overall_score(l);
							//cerr << loss << endl;
							cand.emplace_back(loss,l);
						}
						// cerr << endl;
					}
					// cerr << endl;
					sort(cand.begin(),cand.end(),[&](const pair<double,L> &a,const pair<double,L> &b){
						return a.first < b.first;
						
					});
					for(int i = 0 ; i < cand.size() ; i++){
						L fix_l = GeomUtils::convert_to_integer_line(cand[i].second,p1,p2);
						if( fix_l.a != null_point and GeomUtils::is_separating(fix_l,p1,p2) ){
								// double loss = answer.overall_score() - answer.overall_score(fix_l);
								// cerr << loss -  cand[0].first << endl;
								answer.add_line(fix_l);
								
								break;
						}
					}
				}
			}
			for(int i = 0 ; i < answer.lines.size() ; ){
				vector<L> ls;
				for(int j = 0 ; j < answer.lines.size() ; j++)
					if( i != j ) ls.push_back(answer.lines[j]);
				bool f = true;
				for(int j = 0 ; j < N ; j++){
					for(int k = j+1 ; k < N ; k++){
						P p1 = problem.trees[j].position[problem.trees[j].root];
						P p2 = problem.trees[k].position[problem.trees[k].root];
						bool separated = false;
						for( auto l : ls ){
							if( GeomUtils::is_separating(l,p1,p2) ){
								separated = true;
								break;
							}
						}
						if( !separated ) {
							f = false;
							break;
						}
					}
					if( !f ) break;
				}
				if( f ) {
					answer.lines.erase(answer.lines.begin()+i);
				}else i++;
			}
			ExtendedAnswer hogehoge(&problem);
			for(int i = 0 ; i < answer.lines.size() ; i++){
				hogehoge.add_line(answer.lines[i]);
			}
			answers.push_back(hogehoge);
			random_shuffle(pairs.begin(),pairs.end());
		}
		vector<int> idx;
		for(int i = 0 ; i < answers.size() ; i++)
			idx.push_back(i);
		sort(idx.begin(),idx.end(),[&](int a,int b){
			
			return answers[a].overall_score() > answers[b].overall_score();
		});
		// if( idx.size() > 3 ) idx.resize(3);
		vector<ExtendedAnswer> res_ans;
		for(int i = 0 ; i < idx.size() ; i++)
			res_ans.push_back(answers[idx[i]]);
		
		return remake_trees(&problem,res_ans);
	}
	
	ExtendedAnswer greedy1(Problem &problem){
		Problem problem_processed = *preprocess(problem);
		int N = problem.trees.size();

		vector<pair<double,pair<int,int>>> pairs;
		for(int i = 0 ; i < N ; i++){
			for(int j = i+1; j < N ; j++){
				P p1 = problem.trees[i].position[problem.trees[i].root];
				P p2 = problem.trees[j].position[problem.trees[j].root];
				pairs.push_back({norm(p1-p2),{i,j}});
			}
		}
		sort(pairs.begin(),pairs.end());
		
		ExtendedAnswer answer(&problem_processed);
		for(int li = 0 ; li < pairs.size(); li++){
			int i = pairs[li].second.first;
			int j = pairs[li].second.second;
			P p1 = problem_processed.trees[i].position[problem_processed.trees[i].root];
			P p2 = problem_processed.trees[j].position[problem_processed.trees[j].root];
			bool separated = false;
			for( auto l : answer.lines ){
				if( GeomUtils::is_separating(l,p1,p2) ){
					separated = true;
					break;
				}
			}
			
			if( !separated ){
				vector<pair<double,L>> cand;
				double cur = answer.overall_score();
				for(int m = 0 ; m < 80000 / problem_processed.trees.size() ; m++){
					double A = 1. * xor64() / (unsigned int)(-1);
					double B = 1. * xor64() / (unsigned int)(-1);
					P mp = p1 + (p2-p1) * A;
					complex<double> rot = exp(complex<double>(0,PI*B));
					P vec = (p1-p2) * P(rot.real(),rot.imag());
					L l = L(mp,mp+vec);
					if( l.a != P(-1,-1) and GeomUtils::is_separating(l,p1,p2) ){
						double loss = cur - answer.overall_score(l);
						cand.emplace_back(loss,l);
					}
				}
				sort(cand.begin(),cand.end(),[&](const pair<double,L> &a,const pair<double,L> &b){
					return a.first < b.first;
				});
				for(int i = 0 ; i < cand.size() ; i++){
					L fix_l = GeomUtils::convert_to_integer_line(cand[i].second,p1,p2);
					if( fix_l.a != null_point and GeomUtils::is_separating(fix_l,p1,p2) ){
							answer.add_line(fix_l);
							// answer.draw_sol();
							break;
					}
				}
			}
		}
		
		// return answer;
		answer = answer.refined_answer();
		ExtendedAnswer tmp(&problem);
		for( auto &l : answer.lines )
			tmp.add_line(l);
		answer = tmp;

		
		while ( nowTime() < TIME_LIMIT){
			int failed = 0;
			while( nowTime() < TIME_LIMIT  ){
				double start = nowTime();
				random_shuffle(answer.lines.begin(),answer.lines.end());
				// ExtendedAnswer bef(&problem);
				// ExtendedAnswer aft(&problem);
				// for(int i = 0 ; i < answer.lines.size() ; i++){
					// if( i < answer.lines.size() / 2 ){
						// bef.add_line(answer.lines[i]);
					// }else{
						// aft.add_line(answer.lines[i]);
					// }
				// }
				for(int xxx = 0 ; xxx <  answer.lines.size() ; xxx++){
					if( nowTime() > TIME_LIMIT  ) return answer;
					// cerr << vals[xxx].first << endl;
					// ExtendedAnswer train;
					// if( xxx < answer.lines.size() / 2 ){
						// train = aft;
						// for(int i = 0 ; i < answer.lines.size() / 2 ; i++){
							// if( xxx != i ){
								// train.add_line(answer.lines[i]);
							// }
						// }
					// }else{
						// train = bef;
						// for(int i = answer.lines.size() / 2 ; i < answer.lines.size() ; i++){
							// if( xxx != i ){
								// train.add_line(answer.lines[i]);
							// }
						// }
					// }
					
					ExtendedAnswer train(&problem);
					for(int i = 0 ; i < answer.lines.size() ; i++){
						if( xxx != i ) train.add_line(answer.lines[i]);
					}
					
					// random_shuffle(pairs.begin(),pairs.end());
					for(int li = 0 ; li < pairs.size(); li++){
						int i = pairs[li].second.first;
						int j = pairs[li].second.second;
						P p1 = problem.trees[i].position[problem.trees[i].root];
						P p2 = problem.trees[j].position[problem.trees[j].root];
						bool separated = false;
						for( auto l : train.lines ){
							if( GeomUtils::is_separating(l,p1,p2) ){
								separated = true;
								break;
							}
						}
						
						if( !separated ){
							vector<pair<double,L>> cand;
							double cur = train.overall_score();
							
							for(int m = 0 ; m < 20000 / problem.trees.size() ; m++){
								double A = 1. * xor64() / (unsigned int)(-1);
								double B = 1. * xor64() / (unsigned int)(-1);
								P mp = p1 + (p2-p1) * A;
								complex<double> rot = exp(complex<double>(0,PI*B));
								P vec = (p1-p2) * P(rot.real(),rot.imag());
								L l = L(mp,mp+vec);
								if( l.a != P(-1,-1) and GeomUtils::is_separating(l,p1,p2) ){
									double loss = cur - train.overall_score(l);
									cand.emplace_back(loss,l);
								}
							}
							sort(cand.begin(),cand.end(),[&](const pair<double,L> &a,const pair<double,L> &b){
								return a.first < b.first;
							});
							for(int i = 0 ; i < cand.size() ; i++){
								L fix_l = GeomUtils::convert_to_integer_line(cand[i].second,p1,p2);
								if( fix_l.a != null_point and GeomUtils::is_separating(fix_l,p1,p2) ){
										train.add_line(fix_l);
										break;
								}
							}
						}
					}
					train = train.refined_answer();
					if( train.overall_score() > answer.overall_score() ){
						cerr << train.overall_score() - answer.overall_score() << "|" << train.overall_score() << "|" << xxx << endl;
						answer = train;
						// if( configuration.visualize_mode ) answer.draw_sol();
						break;
					}else{
						// failed = max(failed,xxx+1);
					}
					
				}
				cerr << nowTime() - start << endl;
				
			}
		}
		return answer;
	}
	
};
#ifdef LOCAL
template<class T> void getVector(vector<T>& v) {
    for (int i = 0; i < v.size(); ++i)
        cin >> v[i];
}



int main(int argc,char *argv[]) {
	if( argc >= 2 && string(argv[1]) == "-vis" ){
		cerr << "visualize mode on" << endl;
		configuration.visualize_mode = true;
	}
    int NP;
    cin >> NP;
    int Npoints;
    cin >> Npoints;
    vector<int> points(Npoints);
    getVector(points);

    int Nroots;
    cin >> Nroots;
    vector<int> roots(Nroots);
    getVector(roots);

    CutTheRoots cr;
    vector<int> ret = cr.makeCuts(NP, points, roots);
	
	if( !configuration.visualize_mode ){
		cout << ret.size() << endl;
		for (int i = 0; i < ret.size(); ++i) {
			cout << ret[i] << endl;
		}
		cout.flush();
	}
}
#endif
